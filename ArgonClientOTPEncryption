// Guide to Inernet of Things Chapter 3
// ArgonClientOTPEncryption
// This Argon firmware demonstrates One Time Pad encryption.

#include <Base64RK.h>
#include <HttpClient.h>


// Define an http client object.
 HttpClient http;

 // Define a headers array holding two http_header_t objects.
 // Our request will include a JSON string. We inform the receiver
 // that it should expect to see JSON.
 http_header_t headers[] = {
    { "Content-Type", "application/json" },
    { NULL, NULL }
 };
 // Define an HTTP request object and an HTTP response object.
 // These objects hold the HTTP request and response.
 http_request_t request;
 http_response_t response;

// The photo resistor is on pin A0
int photoResistor = A0;

// We define a variable to hold the analog value.
int analogValue = 0;

// We define a variable to hold the device ID.
char deviceID[60];

// Setup is performed once on start up.
void setup() {

   // We prepare to write to the serial port.
   Serial.begin(9600);

   // In the request object, set the IP address and port of the server that
   // we will visit.
   request.ip = IPAddress(192,168,86,164);
   request.port = 3000;

   // The deviceID is found by calling System.deviceID().c_str();
   // Here, we copy the device ID into the character array named deviceID.
   strcpy(deviceID,System.deviceID().c_str());

   // For debugging, write to the console over the serial port.
   Serial.printlnf("This device has the id %s", deviceID);

 }

 // Provided with a response, display it to the command line interface.
 void printResponse(http_response_t &response) {
   Serial.println("HTTP Response: ");
   Serial.println(response.status);
   Serial.println(response.body);
 }


 void doPostRequest(char encryptedByteArrayBase64[]) {

   // Provide the path to the service
   request.path = "/microcontrollerEvent";

   // Build the JSON request
   char json[1000] = "{\"encryptedData\":\"";
   // Add the encrypted data
   strcat(json,encryptedByteArrayBase64);
   // add the JSON ending
   strcat(json,"\"}");
   // assign the JSON string to the HTTP request body
   request.body = json;
   // post the request
   http.post(request, response, headers);
   // show response
   printResponse(response);
 }


 void loop() {

    analogValue = analogRead(photoResistor);
    Serial.printlnf("AnalogValue == %u", analogValue);

    // clear text message local to the device
    char clearText[80];
    sprintf(clearText, "Argon ID = %s Light sensor value = %d", deviceID, analogValue);
    Serial.printlnf("Clear text: %s",clearText);

     // determine its length of the string holding the clear text
    int lengthOfClearText = strlen(clearText);

    // Allocate space and move clear text into a byte array
    byte *clearTextBytes = (byte *)calloc(lengthOfClearText, sizeof(byte));
    for(int t = 0; t < lengthOfClearText; t = t + 1) clearTextBytes[t] = (byte) clearText[t];

    // The key is local to the device
    char key[] = "This must be truly random, as long as the clear text and used only once.";

    // determine its length
    int lengthOfKey = strlen(key);

    // Allocate space and move the key text into a byte array
    byte *keyBytes = (byte *)calloc(lengthOfKey, sizeof(byte));
    for(int t = 0; t < lengthOfKey; t = t + 1) keyBytes[t] = (byte) key[t];

    // Encrypt the clear text bytes using a one time pad and a key
    byte* cipherTextBytes = encrypt(clearTextBytes,lengthOfClearText,keyBytes,lengthOfKey);

    // Decrypt the result into an array of bytes for testing
    byte *decryptedClearTextBytes = decrypt(cipherTextBytes,lengthOfClearText,keyBytes,lengthOfKey);

    // Extract the bytes from the byte array into a newly allocated string
    char *decryptedClearText = (char *)calloc(lengthOfClearText + 1, sizeof(byte));
    for(int k = 0; k < lengthOfClearText; k = k + 1) decryptedClearText[k] = (char) decryptedClearTextBytes[k];

    // add the null byte back. The null byte was not part of the data that was encrypted
    decryptedClearText[lengthOfClearText +1] = '\0';

    // Show the result for testing
    Serial.printlnf("Decrypted clear text: %s",decryptedClearText);

    // Free up the memory that was allocated for the arrays.
    free(clearTextBytes);
    free(keyBytes);
    free(cipherTextBytes);
    free(decryptedClearTextBytes);
    free(decryptedClearText);

    // encode a byte array in Base64
   size_t sizeOfBase64 = Base64::getEncodedSize(lengthOfClearText, true);
   char * encryptedByteArrayBase64 = (char *)calloc(sizeOfBase64, sizeof(char));
   Base64::encode(cipherTextBytes, lengthOfClearText, encryptedByteArrayBase64, sizeOfBase64, true );
   Serial.println(encryptedByteArrayBase64);

   // Make an HTTP Post request along with JSON containing encrypted data
   doPostRequest(encryptedByteArrayBase64);

   // Should we free encryptedByteArrayBase64
   // Should we add timing logic instead of delay(5000);
   delay(5000);
 }

// One time pad encryption
byte* encrypt(byte clearTextBytes[], int lengthOfClearText, byte keyBytes[], int lengthOfKey) {

     int keyIndex = 0;
     byte *cipherTextBytes = (byte *)calloc(lengthOfClearText, sizeof(byte) );
     for (int index = 0; index < (lengthOfClearText); index = index + 1) {
         cipherTextBytes[index] = clearTextBytes[index] ^ keyBytes[keyIndex];
         // rotate through the key
         keyIndex = (keyIndex + 1) % lengthOfKey;
     }
     return cipherTextBytes;
}

// One time pad decryption
byte* decrypt(byte cipherTextBytes[], int lengthOfClearText, byte keyBytes[], int lengthOfKey) {

     int keyIndex = 0;
     byte *decryptedClearTextBytes = (byte *)calloc(lengthOfClearText, sizeof(byte));
     for (int index = 0; index < (lengthOfClearText); index = index + 1) {
         decryptedClearTextBytes[index] = cipherTextBytes[index] ^ keyBytes[keyIndex];
         // rotate through the key
         keyIndex = (keyIndex + 1) % lengthOfKey;

     }
     return decryptedClearTextBytes;
}
